module AskFi.Sdk
open System.Collections.Generic
open System.Runtime.CompilerServices
open System.Threading.Tasks
open System
open AskFi.Persistence

// ######################
// #### OBSERVATIONS ####
// ######################

// This is a non-deterministic id generated by the IObserver implementation to correlate multiple observations into a continuum.
// Todo: implement equitable. And make it collision-resistant between Observer instances that use the same underlying binary representation but refer to different (i.e. their own) ObservationSessions.
// In the runtime, it's represented as untyped bytes. Three identities are namespaced within an IObserver-instance.
[<IsReadOnly; Struct>]
type ContinuityCorrelationId =
    | ContinuityCorrelationId of uint64

/// An atomic appearance of sensory information.
/// Includes a Perception, which is a typed (via a domain model) representation of the newly observed information.
/// An observation can have multiple Perceptions in case they all appeared at the same instant (point in time).
/// An individual observation, by definition, appeared at a singular instant (point in time)
/// And references an ObservationSession, which can be used by the IObserver implementation to correlate multiple Observations into a continuity
/// (useful for expressing that the observation was exhaustive, e.g. there were no trades in between these two observed trades because they are immediate "neighbors" within the same observation session)
[<IsReadOnly; Struct>]
type Observation<'Perception> = {
    Continuity: ContinuityCorrelationId option
    Perceptions: 'Perception array
}

type IObserver<'Perception> =
    abstract member Observations : IAsyncEnumerable<Observation<'Perception>>

// #####################
// ####   QUERIES   ####
// #####################

/// Public query interface into a given Perspective.
/// Used by queries, strategies and standalone analysis code to retrieve observations from a Perspective.
type IPerspectiveQueries =
    /// Get the latest received perception of the requested type.
    /// Returns `None` if no observation of the requested type has been made yet.
    abstract member latest<'Perception> : unit -> Observation<'Perception> option

    /// Get an iterator the all Observations of type `'Perception` since the passed `timestamp`
    /// (as determined by the runtime clock used during WorldEventStream sequencing).
    abstract member since<'Perception> : timestamp: DateTime -> Observation<'Perception> seq

    /// Todo: get an ordered sequenced of multiple Perception-types
    /// Get an iterator the all Observations of the two types `'Perception1` and `'Perception2` since (as by the runtime clock used for WorldEventStream sequencing) the passed `timestamp`.
    abstract member since<'Perception1, 'Perception2> : timestamp: DateTime -> System.ValueTuple<Observation<'Perception1> option, Observation<'Perception2> option> seq

type Scene = {
    // Every scene is generated from a single Observation<'P>, thus a single known 'P
    PerceptionType: Type

    // typeof(InstanceKey) -> 'InstanceKey set
    // Across all possible 'InstanceKey (i.e. object classes), list all referenced (instantiated) instances
    ObjectInstances: Map<string, obj list>
}

[<IsReadOnly; Struct>]
type Perspective = {
    /// This references a Sdk.Runtime.DataModel.PerspectiveSequenceHead, which in turn references
    /// all (in this perspective) available observations across all Perception-types.
    LatestPerspectiveSequenceHead: ContentId
    Query: IPerspectiveQueries
}

type Query<'Parameters, 'Result> = 'Parameters -> Perspective * Scene -> 'Result

// ######################
// ####   STRATEGY   ####
// ######################

type ActionInitiation = {
    Action: obj
    Type: System.Type
}

type Decision =
    | Inaction
    | Initiate of Initiatives: ActionInitiation array
    
type IReflectionQueries = interface end

[<IsReadOnly; Struct>]
type Reflection = {
    /// This references a Sdk.Runtime.DataModel.DecisionSequenceHead, which in turn references
    /// all (in this session) actions that have been decided in across all Action-types.
    LatestDecisionSequenceHead: ContentId
    Query: IReflectionQueries
}

/// Contains the code of a strategy decision, called upon each evolution of the Askbot Sessions Perspective (i.e. on every new observation).
type Decide = Reflection -> Perspective -> Decision

// ####################
// #### SIMULATION ####
// ####################

type Interpreter<'Perception, 'InstanceKey when 'InstanceKey : equality> =
    abstract member Interpret : 'Perception -> 'InstanceKey list

/// Simulation function generates fictional observations.
/// Those are free not to use the object classed used to interpret actual observations.
/// They can create independent expectation object classes like 'VirtualTrade' in case of order book backtesting.
type Simulate<'Action> = Perspective * Scene -> 'Action -> Scene

// ####################
// ####   ACTION   ####
// ####################

type IBroker<'Action> =
    abstract member Execute : 'Action -> Task
